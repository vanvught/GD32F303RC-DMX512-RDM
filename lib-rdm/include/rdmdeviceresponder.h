#pragma once
/**
 * @file rdmdeviceresponder.h
 *
 */
/* Copyright (C) 2018-2025 by Arjan van Vught mailto:info@gd32-dmx.org
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <cstdint>
#include <cstring>

#include "hal.h"

#include "rdmconst.h"
#include "rdmdevice.h"
#include "rdmidentify.h"
#include "rdmpersonality.h"
#include "rdmsensors.h"
#include "rdmsubdevices.h"

#include "dmxnode.h"
#include "dmxnode_outputtype.h"

#include "firmwareversion.h"

namespace rdm::device::responder {
static constexpr uint8_t DEFAULT_CURRENT_PERSONALITY = 1;

///< http://rdm.openlighting.org/pid/display?manufacturer=0&pid=96
struct DeviceInfo {
	uint8_t protocol_major;			///< The response for this field shall always be same regardless of whether this message is directed to the Root Device or a Sub-Device.
	uint8_t protocol_minor;			///< The response for this field shall always be same regardless of whether this message is directed to the Root Device or a Sub-Device.
	uint8_t device_model[2];		///< This field identifies the Device Model ID of the Root Device or the Sub-Device. The Manufacturer shall not use the same ID to represent more than one unique model type.
	uint8_t product_category[2];	///< Devices shall report a Product Category based on the products primary function.
	uint8_t software_version[4];	///< This field indicates the Software Version ID for the device. The Software Version ID is a 32-bit value determined by the Manufacturer.
	uint8_t dmx_footprint[2];		///< If the DEVICE_INFO message is directed to a Sub-Device, then the response for this field contains the DMX512 Footprint for that Sub-Device. If the message is sent to the Root Device, it is the Footprint for the Root Device itself. If the Device or Sub-Device does not utilize Null Start Code packets for any control or functionality then it shall report a Footprint of 0x0000.
	uint8_t current_personality;	///<
	uint8_t personality_count;		///<
	uint8_t dmx_start_address[2];	///< If the Device or Sub-Device that this message is directed to has a DMX512 Footprint of 0, then this field shall be set to 0xFFFF.
	uint8_t sub_device_count[2];	///< The response for this field shall always be same regardless of whether this message is directed to the Root Device or a Sub-Device.
	uint8_t sensor_count;			///< This field indicates the number of available sensors in a Root Device or Sub-Device. When this parameter is directed to a Sub-Device, the reply shall be identical for any Sub-Device owned by a specific Root Device.
};
} // namespace rdm::device::responder
namespace configstore {
void SetFactoryDefaults();
}  // namespace configstore

class RDMDeviceResponder: public RDMDevice {
	static constexpr char LANGUAGE[2] = { 'e', 'n' };
public:
	RDMDeviceResponder(RDMPersonality **pRDMPersonalities, const uint32_t nPersonalityCount, const uint32_t nCurrentPersonality = rdm::device::responder::DEFAULT_CURRENT_PERSONALITY) :
		m_pRDMPersonalities(pRDMPersonalities)
	{
		DEBUG_ENTRY

		assert(s_this == nullptr);
		s_this = this;

		m_aLanguage[0] = LANGUAGE[0];
		m_aLanguage[1] = LANGUAGE[1];

		memset(&m_DeviceInfo, 0, sizeof (struct rdm::device::responder::DeviceInfo));
		memset(&m_SubDeviceInfo, 0, sizeof (struct rdm::device::responder::DeviceInfo));

		m_DeviceInfo.personality_count = static_cast<uint8_t>(nPersonalityCount);
		m_DeviceInfo.current_personality =  static_cast<uint8_t>(nCurrentPersonality);

		assert(nCurrentPersonality != 0);

		const auto *pDmxNodeOutputType = m_pRDMPersonalities[nCurrentPersonality - 1]->GetDmxNodeOutputType();

		if (pDmxNodeOutputType == nullptr) {
			m_nDmxStartAddressFactoryDefault = dmxnode::kAddressInvalid;
		}

		DEBUG_EXIT
	}

	virtual ~RDMDeviceResponder() = default;

	void Init() {
		DEBUG_ENTRY

		RDMDevice::Init();

		const auto kSoftwareVersionId = FirmwareVersion::Get()->GetVersionId();
		const auto kDeviceModel = hal::kBoardId;
		const auto kProductCategory = RDMDevice::GetProductCategory();
		const auto kSubDevices = m_RDMSubDevices.GetCount();

		m_DeviceInfo.protocol_major = (E120_PROTOCOL_VERSION >> 8);
		m_DeviceInfo.protocol_minor = static_cast<uint8_t>(E120_PROTOCOL_VERSION);
		m_DeviceInfo.device_model[0] = static_cast<uint8_t>(kDeviceModel >> 8);
		m_DeviceInfo.device_model[1] = static_cast<uint8_t>(kDeviceModel);
		m_DeviceInfo.product_category[0] =static_cast<uint8_t>( kProductCategory >> 8);
		m_DeviceInfo.product_category[1] = static_cast<uint8_t>(kProductCategory);
		m_DeviceInfo.software_version[0] = static_cast<uint8_t>(kSoftwareVersionId >> 24);
		m_DeviceInfo.software_version[1] = static_cast<uint8_t>(kSoftwareVersionId >> 16);
		m_DeviceInfo.software_version[2] = static_cast<uint8_t>(kSoftwareVersionId >> 8);
		m_DeviceInfo.software_version[3] = static_cast<uint8_t>(kSoftwareVersionId);

		assert(m_DeviceInfo.current_personality != 0);
		auto *pDmxNodeOutputType = m_pRDMPersonalities[m_DeviceInfo.current_personality - 1]->GetDmxNodeOutputType();

		if (pDmxNodeOutputType == nullptr) {
			m_DeviceInfo.dmx_footprint[0] = 0;
			m_DeviceInfo.dmx_footprint[1] = 0;
			m_DeviceInfo.dmx_start_address[0] = static_cast<uint8_t>(m_nDmxStartAddressFactoryDefault >> 8);
			m_DeviceInfo.dmx_start_address[1] = static_cast<uint8_t>(m_nDmxStartAddressFactoryDefault);
		} else {
			m_DeviceInfo.dmx_footprint[0] = static_cast<uint8_t>(pDmxNodeOutputType->GetDmxFootprint() >> 8);
			m_DeviceInfo.dmx_footprint[1] = static_cast<uint8_t>(pDmxNodeOutputType->GetDmxFootprint());
			m_DeviceInfo.dmx_start_address[0] = static_cast<uint8_t>(pDmxNodeOutputType->GetDmxStartAddress() >> 8);
			m_DeviceInfo.dmx_start_address[1] = static_cast<uint8_t>(pDmxNodeOutputType->GetDmxStartAddress());
		}

		m_DeviceInfo.sub_device_count[0] = static_cast<uint8_t>(kSubDevices >> 8);
		m_DeviceInfo.sub_device_count[1] = static_cast<uint8_t>(kSubDevices);
		m_DeviceInfo.sensor_count = m_RDMSensors.GetCount();

		memcpy(&m_SubDeviceInfo, &m_DeviceInfo, sizeof(struct rdm::device::responder::DeviceInfo));

		m_nCheckSum = CalculateChecksum();

		DEBUG_EXIT
	}

	void Print() {
		RDMDevice::Print();

		assert(m_DeviceInfo.current_personality != 0);
		const auto *pPersonality = m_pRDMPersonalities[m_DeviceInfo.current_personality - 1];
		assert(pPersonality != nullptr);
		const char *pPersonalityDescription = pPersonality->GetDescription();
		const auto nPersonalityDescriptionLength = pPersonality->GetDescriptionLength();

		puts("RDM Responder configuration");
		printf(" Protocol Version %d.%d\n", m_DeviceInfo.protocol_major, m_DeviceInfo.protocol_minor);
		printf(" DMX Address      : %d\n", (m_DeviceInfo.dmx_start_address[0] << 8) + m_DeviceInfo.dmx_start_address[1]);
		printf(" DMX Footprint    : %d\n", (m_DeviceInfo.dmx_footprint[0] << 8) + m_DeviceInfo.dmx_footprint[1]);
		printf(" Personality %d of %d [%.*s]\n", m_DeviceInfo.current_personality, m_DeviceInfo.personality_count, nPersonalityDescriptionLength, pPersonalityDescription);
		printf(" Sub Devices      : %d\n", (m_DeviceInfo.sub_device_count[0] << 8) + m_DeviceInfo.sub_device_count[1]);
		printf(" Sensors          : %d\n", m_DeviceInfo.sensor_count);
	}

	// E120_DEVICE_INFO				0x0060
	struct rdm::device::responder::DeviceInfo *GetDeviceInfo(uint16_t nSubDevice = RDM_ROOT_DEVICE) {
		if (nSubDevice != RDM_ROOT_DEVICE) {
			const auto *sub_device_info = m_RDMSubDevices.GetInfo(nSubDevice);

			if (sub_device_info != nullptr) {
				m_SubDeviceInfo.dmx_footprint[0] = static_cast<uint8_t>(sub_device_info->dmx_footprint >> 8);
				m_SubDeviceInfo.dmx_footprint[1] = static_cast<uint8_t>(sub_device_info->dmx_footprint);
				m_SubDeviceInfo.current_personality = sub_device_info->current_personality;
				m_SubDeviceInfo.personality_count = sub_device_info->personality_count;
				m_SubDeviceInfo.dmx_start_address[0] = static_cast<uint8_t>(sub_device_info->dmx_start_address >> 8);
				m_SubDeviceInfo.dmx_start_address[1] =  static_cast<uint8_t>(sub_device_info->dmx_start_address);
				m_SubDeviceInfo.sensor_count = sub_device_info->sensor_count;
			}

			return &m_SubDeviceInfo;
		}

		//TODO FIXME Quick fix
		const auto nProductCategory = RDMDevice::GetProductCategory();
		m_DeviceInfo.product_category[0] =static_cast<uint8_t>( nProductCategory >> 8);
		m_DeviceInfo.product_category[1] = static_cast<uint8_t>(nProductCategory);

		return &m_DeviceInfo;
	}

	// E120_DEVICE_LABEL			0x0082
	void SetLabel(uint16_t nSubDevice, const char *pLabel, uint8_t nLabelLength) {
		struct TRDMDeviceInfoData info;

		if (nLabelLength > RDM_DEVICE_LABEL_MAX_LENGTH) {
			nLabelLength = RDM_DEVICE_LABEL_MAX_LENGTH;
		}

		if (nSubDevice != RDM_ROOT_DEVICE) {
			m_RDMSubDevices.SetLabel(nSubDevice, pLabel, nLabelLength);
			return;
		}

		info.data = const_cast<char*>(pLabel);
		info.length = nLabelLength;

		RDMDevice::SetLabel(&info);
	}

	void GetLabel(uint16_t nSubDevice, struct TRDMDeviceInfoData *pInfo) {
		if (nSubDevice != RDM_ROOT_DEVICE) {
			m_RDMSubDevices.GetLabel(nSubDevice, pInfo);
			return;
		}

		RDMDevice::GetLabel(pInfo);
	}

	// E120_FACTORY_DEFAULTS		0x0090
	void SetFactoryDefaults() {
		RDMDevice::SetFactoryDefaults();

		assert(m_pRDMPersonalities != nullptr);

		SetPersonalityCurrent(RDM_ROOT_DEVICE, rdm::device::responder::DEFAULT_CURRENT_PERSONALITY);
		SetDmxStartAddress(RDM_ROOT_DEVICE, m_nDmxStartAddressFactoryDefault);

		memcpy(&m_SubDeviceInfo, &m_DeviceInfo, sizeof(struct rdm::device::responder::DeviceInfo));

		m_RDMSubDevices.SetFactoryDefaults();

		m_nCheckSum = CalculateChecksum();
		m_IsFactoryDefaults = true;

		configstore::SetFactoryDefaults();
	}

	bool GetFactoryDefaults() {
		if (m_IsFactoryDefaults) {
			if (!RDMDevice::GetFactoryDefaults()) {
				m_IsFactoryDefaults = false;
				return false;
			}

			if (m_nCheckSum != CalculateChecksum()) {
				m_IsFactoryDefaults = false;
				return false;
			}

			if (!m_RDMSubDevices.GetFactoryDefaults()) {
				m_IsFactoryDefaults = false;
				return false;
			}
		}

		return m_IsFactoryDefaults;
	}

	// E120_LANGUAGE				0x00B0
	void SetLanguage(const char aLanguage[2]) {
		m_aLanguage[0] = aLanguage[0];
		m_aLanguage[1] = aLanguage[1];
	}
	const char* GetLanguage() const {
		return m_aLanguage;
	}

	// E120_SOFTWARE_VERSION_LABEL	0x00C0
	const char *GetSoftwareVersion() const {
		return FirmwareVersion::Get()->GetSoftwareVersion();
	}

	uint32_t GetSoftwareVersionLength() const {
		return firmwareversion::length::kSoftwareVersion;
	}

	// E120_DMX_START_ADDRESS		0x00F0
	void SetDmxStartAddress(uint16_t nSubDevice, uint16_t nDmxStartAddress) {
		DEBUG_ENTRY

		if (nDmxStartAddress == 0 || nDmxStartAddress > dmxnode::kUniverseSize)
			return;

		if (nSubDevice != RDM_ROOT_DEVICE) {
			m_RDMSubDevices.SetDmxStartAddress(nSubDevice, nDmxStartAddress);
			return;
		}

		const auto *pPersonality = m_pRDMPersonalities[m_DeviceInfo.current_personality - 1];
		assert(pPersonality != nullptr);

		auto *pDmxNodeOutputType = pPersonality->GetDmxNodeOutputType();

		if (pDmxNodeOutputType != nullptr) {
			if (pDmxNodeOutputType->SetDmxStartAddress(nDmxStartAddress)) {
				m_DeviceInfo.dmx_start_address[0] = static_cast<uint8_t>(nDmxStartAddress >> 8);
				m_DeviceInfo.dmx_start_address[1] = static_cast<uint8_t>(nDmxStartAddress);
			}

			DmxStartAddressUpdate();
		}

		DEBUG_EXIT
	}

	uint16_t GetDmxStartAddress(uint16_t nSubDevice = RDM_ROOT_DEVICE) {
		if (nSubDevice != RDM_ROOT_DEVICE) {
			return m_RDMSubDevices.GetDmxStartAddress(nSubDevice);
		}

		return static_cast<uint16_t>((m_DeviceInfo.dmx_start_address[0] << 8) + m_DeviceInfo.dmx_start_address[1]);
	}

	// E120_SLOT_INFO				0x0120
	bool GetSlotInfo(uint16_t nSubDevice,uint16_t nSlotOffset, dmxnode::SlotInfo &tSlotInfo) {
		if (nSubDevice != RDM_ROOT_DEVICE) {
			return false; // TODO GetSlotInfo SubDevice
		}

		const auto *pPersonality = m_pRDMPersonalities[m_DeviceInfo.current_personality - 1];
		auto *pDmxNodeOutputType = pPersonality->GetDmxNodeOutputType();

		return pDmxNodeOutputType->GetSlotInfo(nSlotOffset, tSlotInfo);
	}

	uint16_t GetDmxFootPrint(uint16_t nSubDevice = RDM_ROOT_DEVICE) {
		if (nSubDevice != RDM_ROOT_DEVICE) {
			return m_RDMSubDevices.GetDmxFootPrint(nSubDevice);
		}

		return static_cast<uint16_t>((m_DeviceInfo.dmx_footprint[0] << 8) + m_DeviceInfo.dmx_footprint[1]);
	}

	// Personalities
	RDMPersonality* GetPersonality(uint16_t nSubDevice, uint8_t nPersonality) {
		assert(nPersonality >= 1);

		if (nSubDevice != RDM_ROOT_DEVICE) {
			return m_RDMSubDevices.GetPersonality(nSubDevice, nPersonality);
		}

		assert(nPersonality <= m_DeviceInfo.personality_count);

		return m_pRDMPersonalities[nPersonality - 1];
	}

	uint8_t GetPersonalityCount(uint16_t nSubDevice = RDM_ROOT_DEVICE) {
		if (nSubDevice != RDM_ROOT_DEVICE) {
			return m_RDMSubDevices.GetPersonalityCount(nSubDevice);
		}

		return m_DeviceInfo.personality_count;
	}

	void SetPersonalityCurrent(uint16_t nSubDevice, uint8_t nPersonality) {
		assert(nPersonality >= 1);

		if (nSubDevice != RDM_ROOT_DEVICE) {
			m_RDMSubDevices.SetPersonalityCurrent(nSubDevice, nPersonality);
			return;
		}

		m_DeviceInfo.current_personality = nPersonality;

		assert(nPersonality <= m_DeviceInfo.personality_count);

		const auto *pPersonality = m_pRDMPersonalities[nPersonality - 1];
		assert(pPersonality != nullptr);

		auto *pDmxNodeOutputType = pPersonality->GetDmxNodeOutputType();

		if (pDmxNodeOutputType != nullptr) {
			m_DeviceInfo.dmx_footprint[0] = static_cast<uint8_t>(pDmxNodeOutputType->GetDmxFootprint() >> 8);
			m_DeviceInfo.dmx_footprint[1] = static_cast<uint8_t>(pDmxNodeOutputType->GetDmxFootprint());
			m_DeviceInfo.dmx_start_address[0] = static_cast<uint8_t>(pDmxNodeOutputType->GetDmxStartAddress() >> 8);
			m_DeviceInfo.dmx_start_address[1] = static_cast<uint8_t>(pDmxNodeOutputType->GetDmxStartAddress());

			PersonalityUpdate(pDmxNodeOutputType);
		}
	}

	uint8_t GetPersonalityCurrent(uint16_t nSubDevice = RDM_ROOT_DEVICE) {
		if (nSubDevice != RDM_ROOT_DEVICE) {
			return m_RDMSubDevices.GetPersonalityCurrent(nSubDevice);
		}

		return m_DeviceInfo.current_personality;
	}

	static RDMDeviceResponder *Get() {
		return s_this;
	}

private:
	uint16_t CalculateChecksum() {
		auto nChecksum = static_cast<uint16_t>((m_DeviceInfo.dmx_start_address[0] >> 8) + m_DeviceInfo.dmx_start_address[1]);
		nChecksum = static_cast<uint16_t>(nChecksum + m_DeviceInfo.current_personality);
		return nChecksum;
	}

	virtual void PersonalityUpdate([[maybe_unused]] DmxNodeOutputType *pDmxNodeOutputType) {};
	virtual void DmxStartAddressUpdate() {};

private:
	RDMIdentify m_RDMIdentify;
	RDMSensors m_RDMSensors;
	RDMSubDevices m_RDMSubDevices;
	RDMPersonality **m_pRDMPersonalities;
	rdm::device::responder::DeviceInfo m_DeviceInfo;
	rdm::device::responder::DeviceInfo m_SubDeviceInfo;
	char m_aLanguage[2];
	bool m_IsFactoryDefaults { true };
	uint16_t m_nCheckSum { 0 };
	uint16_t m_nDmxStartAddressFactoryDefault { dmxnode::kStartAddressDefault };

	static inline RDMDeviceResponder *s_this;
};
